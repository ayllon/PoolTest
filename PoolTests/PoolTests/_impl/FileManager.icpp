#include "AlexandriaKernel/memory_tools.h"
#include "PoolTests/FileManager.h"
#include <atomic>

namespace SourceXtractor {

struct FileManager::FileMetadata {
  boost::filesystem::path   m_path;
  bool                      m_write;
  Timestamp                 m_last_used;
  uint64_t                  m_used_count;
  std::function<bool(void)> m_request_close;

  FileMetadata(const boost::filesystem::path& path, bool write)
      : m_path(path), m_write(write), m_last_used(FileManager::Now()), m_used_count(0) {}
};

template <typename TFD>
auto FileManager::open(const boost::filesystem::path& path, bool write, std::function<bool(FileId)> request_close)
    -> std::pair<FileId, TFD> {
  notifyIntentToOpen(write);

  auto   meta           = Euclid::make_unique<FileMetadata>(path, write);
  FileId id             = meta.get();
  meta->m_request_close = [id, request_close]() -> bool { return request_close(id); };

  TFD fd = OpenCloseTrait<TFD>::open(path, write);

  {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_files[id] = std::move(meta);
  }

  notifyOpenedFile(id);
  return std::make_pair(id, std::move(fd));
}

template <typename TFD>
void FileManager::close(FileId id, TFD& fd) {
  OpenCloseTrait<TFD>::close(fd);

  notifyClosedFile(id);

  std::unique_ptr<FileMetadata> meta;
  {
    std::lock_guard<std::mutex> lock(m_mutex);
    auto                        iter = m_files.find(id);
    assert(iter != m_files.end());
    std::swap(meta, iter->second);
    m_files.erase(iter);
  }
}

}  // end of namespace SourceXtractor
