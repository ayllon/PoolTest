#include "PoolTests/FileHandler.h"

namespace SourceXtractor {

template <typename TFD>
FileHandler<TFD>::FileHandler(const boost::filesystem::path& path, std::weak_ptr<FileManager> file_manager)
    : m_path(path), m_file_manager(std::move(file_manager)), m_is_readonly(true) {}

template <typename TFD>
FileHandler<TFD>::~FileHandler() {
  std::lock_guard<std::mutex> this_lock(m_handler_mutex);
  auto                        manager_ptr = m_file_manager.lock();
  for (auto& fd : m_available_fd) {
    manager_ptr->close(fd.first, fd.second);
  }
}

template <typename TFD>
bool FileHandler<TFD>::isReadOnly() const {
  return m_is_readonly;
}

template <typename TFD>
auto FileHandler<TFD>::getAccessor(bool write) -> std::unique_ptr<FileAccessorType> {
  std::lock_guard<std::mutex> this_lock(m_handler_mutex);

  // If we are changing mode, we need to wait for everyone to be released and then close every file descriptor
  if (write xor !m_is_readonly) {
    UniqueLock unique_lock(m_file_mutex);
    auto       manager_ptr = m_file_manager.lock();
    assert(manager_ptr);
    for (auto& fd : m_available_fd) {
      manager_ptr->close(fd.first, fd.second);
    }
    m_available_fd.clear();
    m_is_readonly = !write;
  }

  assert((!m_is_readonly && m_available_fd.size() <= 1) || m_is_readonly);

  // Get one if none available
  if (m_available_fd.empty()) {
    auto manager_ptr = m_file_manager.lock();
    assert(manager_ptr);
    auto fd = manager_ptr->open<TFD>(m_path, write, [this](intptr_t id) { return this->close(id); });
    m_available_fd.emplace(std::move(fd));
  }

  assert(!m_available_fd.empty());

  // Build and return accessor
  auto avail_i = m_available_fd.begin();
  auto fd      = std::move(*avail_i);
  m_available_fd.erase(avail_i);

  intptr_t id              = fd.first;
  auto     return_callback = [this, id](TFD&& fd) {
    std::lock_guard<std::mutex> this_lock(m_handler_mutex);
    m_available_fd[id] = std::move(fd);
  };

  std::unique_ptr<FileAccessorType> accessor;
  if (write) {
    UniqueLock unique_lock(m_file_mutex);
    accessor = std::unique_ptr<FileWriteAccessor<TFD>>(
        new FileWriteAccessor<TFD>(std::move(fd.second), return_callback, std::move(unique_lock)));
  } else {
    SharedLock shared_lock(m_file_mutex);
    accessor = std::unique_ptr<FileReadAccessor<TFD>>(
        new FileReadAccessor<TFD>(std::move(fd.second), return_callback, std::move(shared_lock)));
  }

  return accessor;
}

template <typename TFD>
auto FileHandler<TFD>::tryGetAccessor(bool write) -> std::unique_ptr<FileAccessorType> {
  // TODO: Implement me
  assert(false);
}

template <typename TFD>
bool FileHandler<TFD>::close(intptr_t id) {
  std::unique_lock<std::mutex> this_lock(m_handler_mutex);
  auto                         avail_i = m_available_fd.find(id);
  if (avail_i == m_available_fd.end())
    return false;
  auto fd = std::move(avail_i->second);
  m_available_fd.erase(avail_i);
  this_lock.unlock();

  auto manager_ptr = m_file_manager.lock();
  assert(manager_ptr);
  manager_ptr->close(id, fd);
  return true;
}

}  // end of namespace SourceXtractor
