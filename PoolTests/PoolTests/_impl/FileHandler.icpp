#include "PoolTests/FileHandler.h"

namespace SourceXtractor {

template <typename TFD>
FileHandler<TFD>::FileHandler(const boost::filesystem::path& path, std::weak_ptr<FileManager> file_manager)
    : m_path(path), m_file_manager(std::move(file_manager)), m_is_readonly(true) {}

template <typename TFD>
FileHandler<TFD>::~FileHandler() {
  std::lock_guard<std::mutex> this_lock(m_handler_mutex);
  auto                        manager_ptr = m_file_manager.lock();
  for (auto& fd : m_available_fd) {
    manager_ptr->close(fd.first, fd.second);
  }
}

template <typename TFD>
bool FileHandler<TFD>::isReadOnly() const {
  return m_is_readonly;
}

template <typename TFD>
auto FileHandler<TFD>::getWriteAccessor(bool try_lock) -> std::unique_ptr<FileAccessorType> {
  UniqueLock unique_lock(m_file_mutex, boost::defer_lock);
  if (try_lock && !unique_lock.try_lock())
    return nullptr;
  else
    unique_lock.lock();

  // The UniqueLock guarantees no-one else has access to the file and/or metadata

  auto manager_ptr = m_file_manager.lock();
  assert(manager_ptr);

  // If we have changed mode, we need to close all existing fd
  if (m_is_readonly) {
    for (auto& fd : m_available_fd) {
      manager_ptr->close(fd.first, fd.second);
    }
    m_available_fd.clear();
    m_is_readonly = false;
  }

  assert(m_available_fd.size() <= 1);

  // Open one file if we need
  if (m_available_fd.empty()) {
    auto fd = manager_ptr->open<TFD>(m_path, true, [this](FileManager::FileId id) { return this->canBeClosed(id); });
    m_available_fd.emplace(std::move(fd));
  }

  // Build and return accessor
  auto avail_i = m_available_fd.begin();
  auto fd      = std::move(*avail_i);
  m_available_fd.erase(avail_i);

  FileManager::FileId id              = fd.first;
  auto                return_callback = [this, id](TFD&& returned_fd) {
    std::lock_guard<std::mutex> lambda_this_lock(m_handler_mutex);
    m_available_fd[id] = std::move(returned_fd);
  };

  manager_ptr->notifyUsed(id);
  return std::unique_ptr<FileWriteAccessor<TFD>>(
      new FileWriteAccessor<TFD>(std::move(fd.second), return_callback, std::move(unique_lock)));
}

template <typename TFD>
auto FileHandler<TFD>::getReadAccessor(bool try_lock) -> std::unique_ptr<FileAccessorType> {
  SharedLock shared_lock(m_file_mutex, boost::defer_lock);
  if (try_lock && !shared_lock.try_lock())
    return nullptr;
  else
    shared_lock.lock();

  // There may be multiple threads here, since the lock is shared
  std::lock_guard<std::mutex> this_lock(m_handler_mutex);

  auto manager_ptr = m_file_manager.lock();
  assert(manager_ptr);

  // If we have changed mode, we need to close all existing fd
  if (!m_is_readonly) {
    for (auto& fd : m_available_fd) {
      manager_ptr->close(fd.first, fd.second);
    }
    m_available_fd.clear();
    m_is_readonly = true;
  }

  // Open one file if we need
  if (m_available_fd.empty()) {
    auto fd = manager_ptr->open<TFD>(m_path, false, [this](FileManager::FileId id) { return this->canBeClosed(id); });
    m_available_fd.emplace(std::move(fd));
  }

  // Build and return accessor
  auto avail_i = m_available_fd.begin();
  auto fd      = std::move(*avail_i);
  m_available_fd.erase(avail_i);

  FileManager::FileId id              = fd.first;
  auto                return_callback = [this, id](TFD&& returned_fd) {
    std::lock_guard<std::mutex> lambda_this_lock(m_handler_mutex);
    m_available_fd[id] = std::move(returned_fd);
  };

  manager_ptr->notifyUsed(id);
  return std::unique_ptr<FileReadAccessor<TFD>>(
      new FileReadAccessor<TFD>(std::move(fd.second), return_callback, std::move(shared_lock)));
}

template <typename TFD>
auto FileHandler<TFD>::getAccessor(Mode mode) -> std::unique_ptr<FileAccessorType> {

  bool write_bool = mode & kWrite;
  bool try_bool   = mode & 0b10;

  std::unique_ptr<FileAccessorType> acc;
  if (write_bool) {
    acc = getWriteAccessor(try_bool);
  } else {
    acc = getReadAccessor(try_bool);
  }
  return acc;
}

template <typename TFD>
bool FileHandler<TFD>::canBeClosed(FileManager::FileId id) {
  std::unique_lock<std::mutex> this_lock(m_handler_mutex);
  return m_available_fd.count(id) > 0;
}

}  // end of namespace SourceXtractor
