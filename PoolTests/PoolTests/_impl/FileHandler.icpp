#include "PoolTests/FileHandler.h"

namespace SourceXtractor {

template <typename TFD>
FileHandler<TFD>::FileHandler(const boost::filesystem::path& path, std::weak_ptr<FileManager> file_manager)
    : m_path(path), m_file_manager(std::move(file_manager)), m_is_readonly(true) {}

template <typename TFD>
FileHandler<TFD>::~FileHandler() {
  std::lock_guard<std::mutex> this_lock(m_handler_mutex);
  auto                        manager_ptr = m_file_manager.lock();
  for (auto& fd : m_available_fd) {
    manager_ptr->close(fd.first, fd.second);
  }
}

template <typename TFD>
bool FileHandler<TFD>::isReadOnly() const {
  return m_is_readonly;
}

template <typename TFD>
auto FileHandler<TFD>::getAccessor(Mode mode) -> std::unique_ptr<FileAccessorType> {
  std::lock_guard<std::mutex> this_lock(m_handler_mutex);

  auto manager_ptr = m_file_manager.lock();
  bool write_mode  = mode & kWrite;
  bool try_mode    = mode & 0b10;

  assert(manager_ptr);

  // If we are changing mode, we need to wait for everyone to be released and then close every file descriptor
  if (write_mode xor !m_is_readonly) {
    UniqueLock unique_lock(m_file_mutex, boost::defer_lock);
    if (!try_mode)
      unique_lock.lock();
    else if (!unique_lock.try_lock())
      return nullptr;

    for (auto& fd : m_available_fd) {
      manager_ptr->close(fd.first, fd.second);
    }
    m_available_fd.clear();
    m_is_readonly = ((mode & 0b01) == kRead);
  }

  assert((!m_is_readonly && m_available_fd.size() <= 1) || m_is_readonly);

  // Get one if none available
  if (m_available_fd.empty()) {
    auto fd = manager_ptr->open<TFD>(m_path, write_mode, [this](FileManager::FileId id) { return this->canBeClosed(id); });
    m_available_fd.emplace(std::move(fd));
  }

  assert(!m_available_fd.empty());

  // Build and return accessor
  auto avail_i = m_available_fd.begin();
  auto fd      = std::move(*avail_i);
  m_available_fd.erase(avail_i);

  FileManager::FileId id              = fd.first;
  auto                return_callback = [this, id](TFD&& returned_fd) {
    std::lock_guard<std::mutex> lambda_this_lock(m_handler_mutex);
    m_available_fd[id] = std::move(returned_fd);
  };

  std::unique_ptr<FileAccessorType> accessor;
  if (write_mode) {
    UniqueLock unique_lock(m_file_mutex, boost::defer_lock_t());
    accessor = std::unique_ptr<FileWriteAccessor<TFD>>(
        new FileWriteAccessor<TFD>(std::move(fd.second), return_callback, std::move(unique_lock)));
  } else {
    SharedLock shared_lock(m_file_mutex);
    accessor = std::unique_ptr<FileReadAccessor<TFD>>(
        new FileReadAccessor<TFD>(std::move(fd.second), return_callback, std::move(shared_lock)));
  }

  manager_ptr->notifyUsed(id);
  return accessor;
}

template <typename TFD>
bool FileHandler<TFD>::canBeClosed(FileManager::FileId id) {
  std::unique_lock<std::mutex> this_lock(m_handler_mutex);
  return m_available_fd.count(id) > 0;
}

}  // end of namespace SourceXtractor
